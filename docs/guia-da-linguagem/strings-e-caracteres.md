---
sidebar_position: 3
---

# Strings e caracteres

## Armazene e manipule texto.

Uma *string* √© uma s√©rie de caracteres, como `"ol√°, mundo"` ou `"albatroz"`. As *strings* em Swift s√£o representadas pelo tipo `String`. O conte√∫do de uma `String` pode ser acessado de v√°rias maneiras, inclusive como uma cole√ß√£o de valores de `Character`.

Os tipos `String` e `Character` do Swift fornecem uma maneira r√°pida, compat√≠vel com Unicode de trabalhar com texto em seu c√≥digo. A sintaxe para cria√ß√£o e manipula√ß√£o de strings √© leve e leg√≠vel, com uma sintaxe literal de *string* semelhante √† linguagem C. A concatena√ß√£o de *strings* √© t√£o simples quanto combinar duas *strings* com o operador `+`, e a mutabilidade de *strings* √© gerenciada escolhendo entre uma constante ou uma vari√°vel, assim como qualquer outro valor em Swift. Voc√™ tamb√©m pode usar *strings* para inserir constantes, vari√°veis, literais e express√µes em *strings* mais longas, em um processo conhecido como interpola√ß√£o de *strings*. Isso facilita a cria√ß√£o de valores de *string* personalizados para exibi√ß√£o, armazenamento, e impress√£o.

Apesar dessa simplicidade de sintaxe, o tipo `String` do Swift √© uma implementa√ß√£o de *string* r√°pida e moderna. Cada *string* √© composta por caracteres Unicode independentes de codifica√ß√£o e oferece suporte para acessar esses caracteres em v√°rias representa√ß√µes Unicode.

> **Nota**
>
> O tipo `String` do Swift √© interligado com a classe `NSString` do Foundation. O Foundation tamb√©m estende o `String` para expor os m√©todos definidos pela `NSString`. Isso significa que, se voc√™ importar o Foundation, poder√° acessar esses m√©todos do `NSString` no `String` sem a necessidade de fazer uma convers√£o expl√≠cita.
>
> Para obter mais informa√ß√µes sobre o uso de `String` com Foundation e Cocoa, consulte [Bridging Between String and NSString](https://developer.apple.com/documentation/swift/string#2919514).

## Literais de String

Voc√™ pode incluir valores de `String` predefinidos em seu c√≥digo como literais de *string*. Um literal de *string* √© uma sequ√™ncia de caracteres cercada por aspas duplas (`"`).

Use um literal de *string* como valor inicial para uma constante ou vari√°vel:

```swift
let algumaString = "Algum valor literal de string"
```

Observe que o Swift infere um tipo de `String `para a constante `algumaString` porque ela √© inicializada com um valor literal de string.

### Literais de String Multilinhas

Se voc√™ precisa de uma *string* que abrange v√°rias linhas, use um literal de *string* multilinhas - uma sequ√™ncia de caracteres cercada por tr√™s aspas duplas:

```swift
let cita√ß√£o = """
O Coelho Branco colocou seus √≥culos. "Por onde devo come√ßar,
por favor, Majestade?" ele perguntou.

"Comece pelo come√ßo", disse o Rei gravemente, "e continue
at√© chegar ao fim; ent√£o pare."
"""
```

Um literal de *string* multilinhas inclui todas as linhas entre suas aspas de abertura e fechamento. A *string* come√ßa na primeira linha ap√≥s as aspas de abertura (`"""`) e termina na linha anterior √†s aspas de fechamento, o que significa que nenhuma das *strings* abaixo come√ßa ou termina com uma quebra de linha:

```swift
let stringEmUmaLinha = "Estas s√£o as mesmas."
let stringMultilinhas = """
Estas s√£o as mesmas.
"""
```

Quando seu c√≥digo-fonte inclui uma quebra de linha dentro de um literal de *string* multilinhas, essa quebra de linha tamb√©m aparece no valor da *string*. Se voc√™ quiser usar quebras de linha para tornar seu c√≥digo-fonte mais leg√≠vel, mas n√£o quiser que as quebras de linha fa√ßam parte do valor da *string*, escreva uma barra invertida (`\`) no final dessas linhas:

```swift
let cita√ß√£oComQuebrasSuaves = """
O Coelho Branco colocou seus √≥culos. "Por onde devo come√ßar, \
por favor, Majestade?" ele perguntou.

"Comece pelo come√ßo", disse o Rei gravemente, "e continue \
at√© chegar ao fim; ent√£o pare."
"""
```

Para criar um literal de *string* multilinhas que come√ßa ou termina com uma alimenta√ß√£o de linha, escreva uma linha em branco como a primeira ou √∫ltima linha. Por exemplo:

```swift
let quebraDeLinha = """

Esta string come√ßa com uma quebra de linha.
Ela tamb√©m termina com uma quebra de linha.

"""
```

Uma *string* multilinhas pode ser recuada para combinar com o c√≥digo circundante. O espa√ßo em branco antes das aspas de fechamento (`"""`) informa ao Swift qual espa√ßo em branco ignorar antes de todas as outras linhas. No entanto, se voc√™ escrever espa√ßo em branco no in√≠cio de uma linha, al√©m do que est√° antes das aspas de fechamento, esse espa√ßo em branco ser√° inclu√≠do.

![multilineStringWhitespace~dark@2x.png (1038√ó258)](https://docs.swift.org/swift-book/images/multilineStringWhitespace~dark@2x.png)

No exemplo acima, mesmo que todo o literal de *string* multilinhas esteja recuado, as primeiras e √∫ltimas linhas da *string* n√£o come√ßam com nenhum espa√ßo em branco. A linha do meio tem mais recuo do que as aspas de fechamento, ent√£o ela come√ßa com esse recuo extra de quatro espa√ßos.

### Caracteres Especiais em Literais de String

Literais de *string* podem incluir os seguintes caracteres especiais:

- Os caracteres especiais escapados `\0` (caractere nulo), `\\` (barra invertida), `\t` (tabula√ß√£o horizontal), `\n` (quebra de linha), `\r` (retorno de carro), `\"` (aspas duplas) e `\'` (aspas simples)
- Um valor escalar Unicode arbitr√°rio, escrito como `\u{`*n*`}`, onde *n* √© um n√∫mero hexadecimal de 1 a 8 d√≠gitos (Unicode √© discutido em [Unicode](#unicode) abaixo)

O c√≥digo abaixo mostra quatro exemplos desses caracteres especiais. A constante `palavrasSabias` cont√©m duas aspas duplas escapadas. As constantes dollarSign, blackHeart e sparklingHeart demonstram o formato escalar Unicode:

```swift
let palavrasSabias = "\"A imagina√ß√£o √© mais importante que o conhecimento\" - Einstein"
// "A imagina√ß√£o √© mais importante que o conhecimento" - Einstein
let cifrao = "\u{24}" // $, Escalar Unicode U+0024
let coracaoPreto = "\u{2665}" // ‚ô•, Escalar Unicode U+2665
let coracaoBrilhante = "\u{1F496}" // üíñ, Escalar Unicode U+1F496
```

Como literais de *string* multilinha usam tr√™s aspas duplas em vez de apenas uma, voc√™ pode incluir uma aspa dupla (`"`) dentro de um literal de *string* multilinha sem escap√°-la. Para incluir o texto `"""` em uma *string* multilinha, escape pelo menos uma das aspas. Por exemplo:

```swift
let tresAspasDuplas = """
Escapando a primeira aspa dupla \"""
Escapando todas as tr√™s aspas duplas \"\"\"
"""
```

### Delimitadores Estendidos de String

Voc√™ pode colocar uma *string* literal dentro de delimitadores estendidos para incluir caracteres especiais em uma *string* sem invocar seu efeito. Voc√™ coloca sua *string* entre aspas (`"`) e envolve isso com sinais de n√∫mero (`#`). Por exemplo, imprimir a *string* literal `#"Linha 1\nLinha 2"#` imprime a sequ√™ncia de escape de quebra de linha (`\n`) em vez de imprimir a *string* em duas linhas.

Se voc√™ precisar dos efeitos especiais de um caractere em uma *string* literal, combine o n√∫mero de sinais de n√∫mero dentro da *string* seguindo o caractere de escape (`\`). Por exemplo, se sua *string* for `#"Linha 1\nLinha 2"#` e voc√™ quiser quebrar a linha, voc√™ pode usar `#"Linha 1\#nLinha 2"#` em vez disso. Da mesma forma, `###"Linha1\###nLinha2"###` tamb√©m quebra a linha.

As literais de *string* criadas usando delimitadores estendidos tamb√©m podem ser literais de *string* de v√°rias linhas. Voc√™ pode usar delimitadores estendidos para incluir o texto `"""` em uma *string* de v√°rias linhas, substituindo o comportamento padr√£o que encerra a literal. Por exemplo:

```swift
let tresAspasDuplasAdicionais = #"""
Aqui est√£o mais tr√™s aspas duplas: """
"""#
```

## Inicializando uma String Vazia

Para criar um valor de `String` vazio como ponto de partida para construir uma *string* mais longa, voc√™ pode atribuir uma *string* vazia a uma vari√°vel ou inicializar uma nova inst√¢ncia de `String` com a sintaxe de inicializador:

```swift
var stringVazia = ""               // literal de string vazia
var outraStringVazia = String()  // sintaxe de inicializador
// essas duas strings est√£o ambas vazias e s√£o equivalentes uma √† outra
```

Descubra se um valor de `String` est√° vazio verificando sua propriedade Booleana `isEmpty`:

```swift
if stringVazia.isEmpty {
    print("Nada para ver aqui")
}
// Imprime "Nada para ver aqui"
```

## Mutabilidade de Strings

Voc√™ indica se uma determinada `String` pode ser modificada (ou mutada) atribuindo-a a uma vari√°vel (nesse caso, ela pode ser modificada) ou a uma constante (nesse caso, ela n√£o pode ser modificada):

```swift
var stringVariavel = "Cavalo"
stringVariavel += " e carruagem"
// stringVariavel agora √© "Cavalo e carruagem"

let stringConstante = "Highlander"
stringConstante += " e outro Highlander"
// isso gera um erro de compila√ß√£o - uma string constante n√£o pode ser modificada
```

> **Nota**
>
> Essa abordagem √© diferente da muta√ß√£o de *strings* em Objective-C e Cocoa, onde voc√™ escolhe entre duas classes (`NSString` e `NSMutableString`) para indicar se uma string pode ser mutada.

## As Strings s√£o tipos de valor

O tipo `String` do Swift √© um tipo de valor. Se voc√™ criar um novo valor de `String`, esse valor de `String` ser√° copiado quando for passado para uma fun√ß√£o ou m√©todo, ou quando for atribu√≠do a uma constante ou vari√°vel. Em cada caso, uma nova c√≥pia do valor de `String` existente √© criada e a nova c√≥pia √© passada ou atribu√≠da, n√£o a vers√£o original. Tipos de valor s√£o descritos em [Estruturas e Enumera√ß√µes S√£o Tipos de Valor](./estruturas-e-classes.md/#estruturas-e-enumera√ß√µes-s√£o-tipos-de-valor).

O comportamento padr√£o de c√≥pia de `String` do Swift garante que, quando uma fun√ß√£o ou m√©todo lhe passa um valor de `String`, fica claro que voc√™ possui exatamente aquele valor de `String`, independentemente de onde ele tenha vindo. Voc√™ pode ter a certeza de que a *string* passada n√£o ser√° modificada a menos que voc√™ a modifique.

Nos bastidores, o compilador do Swift otimiza o uso de *strings* para que a c√≥pia real ocorra apenas quando absolutamente necess√°rio. Isso significa que voc√™ sempre obt√©m um √≥timo desempenho ao trabalhar com *strings* como tipos de valor.

## Trabalhando com caracteres

Voc√™ pode acessar os valores individuais de `Character` de uma `string` iterando sobre a *string* com um loop for-in:

```swift
for caractere in "C√£o!üê∂" {
    print(caractere)
}
// C
// √£
// o
// !
// üê∂
```

O loop for-in √© descrito em [Loops For-In](./controle-de-fluxo.md/#loops-for-in).

Alternativamente, voc√™ pode criar uma constante ou vari√°vel aut√¥noma do tipo `Character` a partir de um literal de *string* de um √∫nico caractere, fornecendo uma anota√ß√£o de tipo `Character`:

```swift
let pontoDeExclamacao: Character = "!"
```

Valores de `String` podem ser constru√≠dos passando um *array* de valores de `Character` como argumento para seu inicializador:

```swift
let caracteresDeGato: [Character] = ["G", "a", "t", "o", "!", "üê±"]
let stringDeGato = String(caracteresDeGato)
print(stringDeGato)
// Imprime "Gato!üê±"
```

## Interpola√ß√£o de String

## Unicode
